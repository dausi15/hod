// this file contains the set of query operators generated by the query planner
package db

import (
	"fmt"

	"github.com/gtfierro/hod/query"
	"github.com/pkg/errors"
	"github.com/syndtr/goleveldb/leveldb"
)

type operation interface {
	run(ctx *queryContext) error
	String() string
	SortKey() string
	GetTerm() *queryTerm
}

// ?subject predicate object
// Find all subjects part of triples with the given predicate and object
type resolveSubject struct {
	term *queryTerm
}

func (rs *resolveSubject) String() string {
	return fmt.Sprintf("[resolveSubject %s]", rs.term)
}

func (rs *resolveSubject) SortKey() string {
	return rs.term.Subject.String()
}

func (rs *resolveSubject) GetTerm() *queryTerm {
	return rs.term
}

func (rs *resolveSubject) run(ctx *queryContext) error {
	// fetch the object from the graph
	object, err := ctx.db.GetEntity(rs.term.Object)
	if err != nil && err != leveldb.ErrNotFound {
		return errors.Wrap(err, fmt.Sprintf("%+v", rs.term))
	} else if err == leveldb.ErrNotFound {
		return nil
	}
	subjectVar := rs.term.Subject.String()
	// get all subjects reachable from the given object along the path
	subjects := ctx.db.getSubjectFromPredObject(object.PK, rs.term.Path)

	ctx.define(subjectVar, subjects)

	return nil
}

// object predicate ?object
// Find all objects part of triples with the given predicate and subject
type resolveObject struct {
	term *queryTerm
}

func (ro *resolveObject) String() string {
	return fmt.Sprintf("[resolveObject %s]", ro.term)
}

func (ro *resolveObject) SortKey() string {
	return ro.term.Object.String()
}

func (ro *resolveObject) GetTerm() *queryTerm {
	return ro.term
}

func (ro *resolveObject) run(ctx *queryContext) error {
	// fetch the subject from the graph
	subject, err := ctx.db.GetEntity(ro.term.Subject)
	if err != nil && err != leveldb.ErrNotFound {
		return errors.Wrap(err, fmt.Sprintf("%+v", ro.term))
	} else if err == leveldb.ErrNotFound {
		return nil
	}
	objectVar := ro.term.Object.String()
	// get all objects reachable from the given subject along the path
	objects := ctx.db.getObjectFromSubjectPred(subject.PK, ro.term.Path)

	ctx.define(objectVar, objects)

	return nil
}

// object ?predicate object
// Find all predicates part of triples with the given subject and subject
type resolvePredicate struct {
	term *queryTerm
}

func (op *resolvePredicate) String() string {
	return fmt.Sprintf("[resolvePredicate %s]", op.term)
}

func (op *resolvePredicate) SortKey() string {
	return op.term.Path[0].Predicate.String()
}

func (op *resolvePredicate) GetTerm() *queryTerm {
	return op.term
}

func (op *resolvePredicate) run(ctx *queryContext) error {
	// fetch the subject from the graph
	subject, err := ctx.db.GetEntity(op.term.Subject)
	if err != nil && err != leveldb.ErrNotFound {
		return errors.Wrap(err, fmt.Sprintf("%+v", op.term))
	} else if err == leveldb.ErrNotFound {
		return nil
	}
	// now get object
	object, err := ctx.db.GetEntity(op.term.Object)
	if err != nil && err != leveldb.ErrNotFound {
		return errors.Wrap(err, fmt.Sprintf("%+v", op.term))
	} else if err == leveldb.ErrNotFound {
		return nil
	}

	predicateVar := op.term.Path[0].Predicate.String()
	// get all preds w/ the given end object, starting from the given subject

	predicates := ctx.db.getPredicateFromSubjectObject(subject, object)

	ctx.define(predicateVar, predicates)
	return nil
}

// ?sub pred ?obj
// Find all subjects and objects that have the given relationship
type restrictSubjectObjectByPredicate struct {
	term                *queryTerm
	parentVar, childVar string
}

func (rso *restrictSubjectObjectByPredicate) String() string {
	return fmt.Sprintf("[restrictSubObjByPred %s]", rso.term)
}

func (rso *restrictSubjectObjectByPredicate) SortKey() string {
	return rso.parentVar
}

func (rso *restrictSubjectObjectByPredicate) GetTerm() *queryTerm {
	return rso.term
}

func (rso *restrictSubjectObjectByPredicate) run(ctx *queryContext) error {
	var (
		subjectVar = rso.term.Subject.String()
		objectVar  = rso.term.Object.String()
		subTree, _ = ctx.getValues(subjectVar)
		objTree, _ = ctx.getValues(objectVar)
	)
	// we add the objects on to each subject
	if rso.parentVar == subjectVar {
		// iterate through current subjects
		max := subTree.Max()
		newObjects := newHashTree(3)
		iter := func(subject Key) bool {
			objects := ctx.db.getObjectFromSubjectPred(subject, rso.term.Path)
			objects = ctx.filterIfDefined(objectVar, objects)
			newObjects.mergeFromTree(objects)
			ctx.addReachable(subject, subjectVar, objects, objectVar)
			return subject != max
		}
		subTree.Iter(iter)
		ctx.define(objectVar, newObjects)
	} else if rso.parentVar == objectVar {
		// iterate through current objects
		max := objTree.Max()
		newSubjects := newHashTree(3)
		iter := func(object Key) bool {
			subjects := ctx.db.getSubjectFromPredObject(object, rso.term.Path)
			subjects = ctx.filterIfDefined(subjectVar, subjects)
			newSubjects.mergeFromTree(subjects)
			ctx.addReachable(object, objectVar, subjects, subjectVar)
			return object != max
		}
		objTree.Iter(iter)
		ctx.define(subjectVar, newSubjects)
	} else {
		log.Fatal("unfamiliar situation")
	}
	//log.Debug(rso)
	//for varname, tree := range ctx.candidates {
	//	log.Debug(varname, tree.Len())
	//}
	//	ctx.dumpChildren()

	return nil
}

// ?sub pred ?obj, but we have already resolved the object
// For each of the current
type resolveSubjectFromVarObject struct {
	term *queryTerm
}

func (rsv *resolveSubjectFromVarObject) String() string {
	return fmt.Sprintf("[resolveSubFromVarObj %s]", rsv.term)
}

func (rsv *resolveSubjectFromVarObject) SortKey() string {
	return rsv.term.Object.String()
}

func (rsv *resolveSubjectFromVarObject) GetTerm() *queryTerm {
	return rsv.term
}

// Use this when we have subject and object variables, but only object has been filled in
func (rsv *resolveSubjectFromVarObject) run(ctx *queryContext) error {
	var (
		objectVar  = rsv.term.Object.String()
		subjectVar = rsv.term.Subject.String()
		objTree, _ = ctx.getValues(objectVar)
	)
	max := objTree.Max()
	iter := func(object Key) bool {
		subjects := ctx.db.getSubjectFromPredObject(object, rsv.term.Path)
		ctx.addOrMergeVariable(subjectVar, subjects)
		ctx.addReachable(object, objectVar, subjects, subjectVar)
		return object != max
	}
	objTree.Iter(iter)
	return nil
}

type resolveObjectFromVarSubject struct {
	term *queryTerm
}

func (rov *resolveObjectFromVarSubject) String() string {
	return fmt.Sprintf("[resolveObjFromVarSub %s]", rov.term)
}

func (rov *resolveObjectFromVarSubject) SortKey() string {
	return rov.term.Subject.String()
}

func (rov *resolveObjectFromVarSubject) GetTerm() *queryTerm {
	return rov.term
}

func (rov *resolveObjectFromVarSubject) run(ctx *queryContext) error {
	var (
		objectVar  = rov.term.Object.String()
		subjectVar = rov.term.Subject.String()
		subTree, _ = ctx.getValues(subjectVar)
	)
	max := subTree.Max()
	newObjects := newHashTree(3)
	iter := func(subject Key) bool {
		objects := ctx.db.getObjectFromSubjectPred(subject, rov.term.Path)
		objects = ctx.filterIfDefined(objectVar, objects)
		newObjects.mergeFromTree(objects)
		ctx.addReachable(subject, subjectVar, objects, objectVar)
		return subject != max
	}
	subTree.Iter(iter)
	ctx.define(objectVar, newObjects)
	return nil
}

type resolveObjectFromVarSubjectPred struct {
	term *queryTerm
}

func (op *resolveObjectFromVarSubjectPred) String() string {
	return fmt.Sprintf("[resolveObjFromVarSubPred %s]", op.term)
}

func (op *resolveObjectFromVarSubjectPred) SortKey() string {
	return op.term.Subject.String()
}

func (op *resolveObjectFromVarSubjectPred) GetTerm() *queryTerm {
	return op.term
}

// TODO: implement resolveObjectFromVarSubjectPred
// ?s ?p o
func (rov *resolveObjectFromVarSubjectPred) run(ctx *queryContext) error {
	return nil
}

type resolveSubjectObjectFromPred struct {
	term *queryTerm
}

func (op *resolveSubjectObjectFromPred) String() string {
	return fmt.Sprintf("[resolveSubObjFromPred %s]", op.term)
}

func (op *resolveSubjectObjectFromPred) SortKey() string {
	return op.term.Subject.String()
}

func (op *resolveSubjectObjectFromPred) GetTerm() *queryTerm {
	return op.term
}

func (rso *resolveSubjectObjectFromPred) run(ctx *queryContext) error {
	subsobjs := ctx.db.getSubjectObjectFromPred(rso.term.Path)
	subjectVar := rso.term.Subject.String()
	objectVar := rso.term.Object.String()
	subjects := newHashTree(3)
	objects := newHashTree(3)
	for _, sopair := range subsobjs {
		subject := sopair[0]
		object := sopair[1]
		if ctx.candidateHasValue(subjectVar, subject) && ctx.candidateHasValue(objectVar, object) {
			ctx.addReachableSingle(subject, subjectVar, object, objectVar)
			subjects.Add(subject)
			objects.Add(object)
		}
	}
	ctx.define(subjectVar, subjects)
	ctx.define(objectVar, objects)
	return nil
}

type resolveSubjectPredFromObject struct {
	term *queryTerm
}

func (op *resolveSubjectPredFromObject) String() string {
	return fmt.Sprintf("[resolveSubPredFromObj %s]", op.term)
}

func (op *resolveSubjectPredFromObject) SortKey() string {
	return op.term.Path[0].Predicate.String()
}

func (op *resolveSubjectPredFromObject) GetTerm() *queryTerm {
	return op.term
}

// we have an object and want to find subjects/predicates that connect to it.
// If we have partially resolved the predicate, then we iterate through those connected to
// the known object and then pull the associated subjects. We then filter those subjects
// by anything we've already resolved.
// If we have *not* resolved the predicate, then this is easy: just graph traverse from the object
func (op *resolveSubjectPredFromObject) run(ctx *queryContext) error {
	var (
		tree *hashTree
	)
	subjectVar := op.term.Subject.String()
	predicateVar := op.term.Path[0].Predicate.String()

	// fetch the object from the graph
	object, err := ctx.db.GetEntity(op.term.Object)
	if err != nil && err != leveldb.ErrNotFound {
		return errors.Wrap(err, fmt.Sprintf("%+v", op.term))
	} else if err == leveldb.ErrNotFound {
		return nil
	}
	candidateSubjects := newHashTree(2)
	// get all predicates from it
	predicates := ctx.db.getPredicatesFromObject(object)
	// for each subject reachable from each predicate, add the predicate as aa
	// dependent of the subject
	predmax := predicates.Max()
	iterpred := func(predicate Key) bool {
		path := []query.PathPattern{{Predicate: ctx.db.MustGetURI(predicate), Pattern: query.PATTERN_SINGLE}}
		subjects := ctx.db.getSubjectFromPredObject(object.PK, path)
		max := subjects.Max()
		iter := func(ent Key) bool {
			tree = ctx.getLinkedValues(predicateVar, ent)
			tree.Add(predicate)
			candidateSubjects.Add(ent) // subject
			ctx.addReachable(ent, subjectVar, tree, predicateVar)
			return ent != max
		}
		subjects.Iter(iter)
		return predicate != predmax
	}
	predicates.Iter(iterpred)

	// need to merge w/ the subjects we've already gotten
	ctx.addOrFilterVariable(subjectVar, candidateSubjects)

	return nil
}

type resolvePredObjectFromSubject struct {
	term *queryTerm
}

func (op *resolvePredObjectFromSubject) String() string {
	return fmt.Sprintf("[resolvePredObjectFromSubject %s]", op.term)
}

func (op *resolvePredObjectFromSubject) SortKey() string {
	return op.term.Path[0].Predicate.String()
}

func (op *resolvePredObjectFromSubject) GetTerm() *queryTerm {
	return op.term
}

func (op *resolvePredObjectFromSubject) run(ctx *queryContext) error {
	var (
		tree *hashTree
	)
	objectVar := op.term.Object.String()
	predicateVar := op.term.Path[0].Predicate.String()

	// fetch the subject from the graph
	subject, err := ctx.db.GetEntity(op.term.Subject)
	if err != nil && err != leveldb.ErrNotFound {
		return errors.Wrap(err, fmt.Sprintf("%+v", op.term))
	} else if err == leveldb.ErrNotFound {
		return nil
	}
	candidateObjects := newHashTree(2)
	// get all predicates from it
	predicates := ctx.db.getPredicatesFromSubject(subject)
	predmax := predicates.Max()
	iterpred := func(predicate Key) bool {
		path := []query.PathPattern{{Predicate: ctx.db.MustGetURI(predicate), Pattern: query.PATTERN_SINGLE}}
		objects := ctx.db.getObjectFromSubjectPred(subject.PK, path)
		max := objects.Max()
		iter := func(ent Key) bool {
			tree = ctx.getLinkedValues(predicateVar, ent)
			tree.Add(predicate)
			candidateObjects.Add(ent) // object
			ctx.addReachable(ent, objectVar, tree, predicateVar)
			return ent != max
		}
		objects.Iter(iter)
		return predicate != predmax
	}
	predicates.Iter(iterpred)

	// need to merge w/ the objects we've already gotten
	ctx.addOrFilterVariable(objectVar, candidateObjects)

	return nil
}

// TODO: implement these for ?s ?p ?o constructs
// TODO: also requires query planner
type resolveVarTripleFromSubject struct {
	term *queryTerm
}

func (op *resolveVarTripleFromSubject) String() string {
	return fmt.Sprintf("[resolveVarTripleFromSubject %s]", op.term)
}

func (op *resolveVarTripleFromSubject) SortKey() string {
	return op.term.Subject.String()
}

func (op *resolveVarTripleFromSubject) GetTerm() *queryTerm {
	return op.term
}

// ?s ?p ?o; start from s
func (op *resolveVarTripleFromSubject) run(ctx *queryContext) error {
	// for all subjects, find all predicates and objects. Note: these predicates
	// and objects may be partially evaluated already
	var (
		subjectVar                     = op.term.Subject.String()
		objectVar                      = op.term.Object.String()
		predicateVar                   = op.term.Path[0].Predicate.String()
		subjects, _                    = ctx.getValues(subjectVar)
		knownPredicates, hadPredicates = ctx.getValues(predicateVar)
		candidateObjects               = newHashTree(2)
		candidatePredicates            = newHashTree(2)
	)

	maxSub := subjects.Max()
	var predKey Key
	subjectIter := func(subjecthash Key) bool {
		linkedPredicates := newHashTree(2)
		subject := ctx.db.MustGetEntityFromHash(subjecthash)
		for edge, objectList := range subject.OutEdges {
			predKey.FromSlice([]byte(edge))
			predicate := predKey
			if hadPredicates && !knownPredicates.Has(predicate) {
				continue // skip
			}
			candidatePredicates.Add(predicate)
			linkedPredicates.Add(predicate)
			linkedObjects := newHashTree(2)
			for _, objectKey := range objectList {
				object := objectKey
				candidateObjects.Add(object)
				linkedObjects.Add(object)
			}
			ctx.addReachable(predicate, predicateVar, linkedObjects, objectVar)
		}
		ctx.addReachable(subjecthash, subjectVar, linkedPredicates, predicateVar)
		return subjecthash != maxSub
	}
	subjects.Iter(subjectIter)
	ctx.addOrMergeVariable(objectVar, candidateObjects)
	ctx.addOrMergeVariable(predicateVar, candidatePredicates)
	return nil
}

type resolveVarTripleFromObject struct {
	term *queryTerm
}

func (op *resolveVarTripleFromObject) String() string {
	return fmt.Sprintf("[resolveVarTripleFromObject %s]", op.term)
}

func (op *resolveVarTripleFromObject) SortKey() string {
	return op.term.Object.String()
}

func (op *resolveVarTripleFromObject) GetTerm() *queryTerm {
	return op.term
}

// ?s ?p ?o; start from o
func (op *resolveVarTripleFromObject) run(ctx *queryContext) error {
	var (
		subjectVar                     = op.term.Subject.String()
		objectVar                      = op.term.Object.String()
		predicateVar                   = op.term.Path[0].Predicate.String()
		objects, _                     = ctx.getValues(objectVar)
		knownPredicates, hadPredicates = ctx.getValues(predicateVar)
		candidateSubjects              = newHashTree(2)
		candidatePredicates            = newHashTree(2)
	)

	maxObj := objects.Max()
	var predKey Key
	objectIter := func(objecthash Key) bool {
		linkedPredicates := newHashTree(2)
		object := ctx.db.MustGetEntityFromHash(objecthash)
		for edge, subjectList := range object.InEdges {
			predKey.FromSlice([]byte(edge))
			predicate := predKey
			if hadPredicates && !knownPredicates.Has(predicate) {
				continue // skip
			}
			candidatePredicates.Add(predicate)
			linkedPredicates.Add(predicate)
			linkedSubjects := newHashTree(2)
			for _, subjectKey := range subjectList {
				subject := subjectKey
				candidateSubjects.Add(subject)
				linkedSubjects.Add(subject)
			}
			ctx.addReachable(predicate, predicateVar, linkedSubjects, subjectVar)
		}
		ctx.addReachable(objecthash, objectVar, linkedPredicates, predicateVar)
		return objecthash != maxObj
	}
	objects.Iter(objectIter)
	ctx.addOrMergeVariable(subjectVar, candidateSubjects)
	ctx.addOrMergeVariable(predicateVar, candidatePredicates)
	return nil
}

type resolveVarTripleFromPredicate struct {
	term *queryTerm
}

func (op *resolveVarTripleFromPredicate) String() string {
	return fmt.Sprintf("[resolveVarTripleFromPredicate %s]", op.term)
}

func (op *resolveVarTripleFromPredicate) SortKey() string {
	return op.term.Path[0].Predicate.String()
}

func (op *resolveVarTripleFromPredicate) GetTerm() *queryTerm {
	return op.term
}

// ?s ?p ?o; start from p
func (op *resolveVarTripleFromPredicate) run(ctx *queryContext) error {
	// for all predicates, pull the entity from the predindex
	var (
		subjectVar        = op.term.Subject.String()
		objectVar         = op.term.Object.String()
		predicateVar      = op.term.Path[0].Predicate.String()
		predicates, _     = ctx.getValues(predicateVar)
		candidateObjects  = newHashTree(2)
		candidateSubjects = newHashTree(2)
	)
	predMax := predicates.Max()
	predIter := func(ent Key) bool {
		uri := ctx.db.MustGetURI(ent)
		predicate := ctx.db.predIndex[uri]
		// iter through subjects
		linkedSubjects := newHashTree(2)
		for subStrHash, subjectMap := range predicate.Subjects {
			var subjectHash Key
			copy(subjectHash[:], []byte(subStrHash))
			subject := subjectHash
			candidateSubjects.Add(subject)
			linkedSubjects.Add(subject)
			linkedObjects := newHashTree(2)
			// link objects to subject
			for objStrHash := range subjectMap {
				var objectHash Key
				copy(objectHash[:], []byte(objStrHash))
				object := objectHash
				candidateObjects.Add(object)
				linkedObjects.Add(object)
			}
			ctx.addReachable(subject, subjectVar, linkedObjects, objectVar)
		}
		ctx.addReachable(ent, predicateVar, linkedSubjects, subjectVar)
		return ent != predMax
	}
	predicates.Iter(predIter)
	ctx.addOrMergeVariable(objectVar, candidateObjects)
	ctx.addOrMergeVariable(subjectVar, candidateSubjects)
	return nil
}

type resolveVarTripleAll struct {
	term *queryTerm
}

func (op *resolveVarTripleAll) String() string {
	return fmt.Sprintf("[resolveVarTripleAll %s]", op.term)
}

func (op *resolveVarTripleAll) SortKey() string {
	return op.term.Subject.String()
}

func (op *resolveVarTripleAll) GetTerm() *queryTerm {
	return op.term
}

// ?s ?p ?o; start from s
func (op *resolveVarTripleAll) run(ctx *queryContext) error {
	return nil
}
